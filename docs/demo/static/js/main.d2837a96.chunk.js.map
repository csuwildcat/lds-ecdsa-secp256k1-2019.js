{"version":3,"sources":["../../../src/keyUtils.ts","../../../src/EcdsaSecp256k1KeyClass2019.ts","../../../src/EcdsaSecp256k1Signature2019.ts","../../../src/defaultDocumentLoader.ts","../../../src/convertFragmentsToURIs.ts","../../../src/universalResolver.ts","../../../src/JWS.ts","../../../src/index.ts","App.js","serviceWorker.js","index.js"],"names":["publicKey","transformArrays","value","didDoc","a","jsigs","require","AssertionProofPurpose","purposes","EcdsaSecp256k1KeyClass2019","EcdsaSecp256k1Signature2019","defaultDocumentLoader","vc","App","state","doc","schema","name","homepage","image","this","setState","key","id","controller","privateKeyJwk","kty","crv","d","x","y","kid","suite","sign","compactProof","documentLoader","purpose","signed","verify","res","verified","console","log","credential","type","issuer","issuanceDate","credentialSubject","alumniOf","issue","signedVC","vc_issued","result","vc_verified","className","JSON","stringify","React","Component","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.d2837a96.chunk.js","sourcesContent":["import { __assign, __awaiter, __generator } from \"tslib\";\nimport keyto from '@trust/keyto';\nimport base64url from 'base64url';\nimport crypto from 'crypto';\nimport { binToHex, hexToBin, instantiateSecp256k1 } from 'bitcoin-ts';\nimport stringify from 'json-stringify-deterministic';\nvar compressedHexEncodedPublicKeyLength = 66;\n/**\n * Example\n * ```js\n * {\n *  kty: 'EC',\n *  crv: 'secp256k1',\n *  d: 'rhYFsBPF9q3-uZThy7B3c4LDF_8wnozFUAEm5LLC4Zw',\n *  x: 'dWCvM4fTdeM0KmloF57zxtBPXTOythHPMm1HCLrdd3A',\n *  y: '36uMVGM7hnw-N6GnjFcihWE3SkrhMLzzLCdPMXPEXlA',\n *  kid: 'JUvpllMEYUZ2joO59UNui_XYDqxVqiFLLAJ8klWuPBw'\n * }\n * ```\n * See [rfc7638](https://tools.ietf.org/html/rfc7638) for more details on JWK.\n */\nexport var getKid = function (jwk) {\n    var copy = __assign({}, jwk);\n    delete copy.d;\n    delete copy.kid;\n    delete copy.alg;\n    var digest = crypto\n        .createHash('sha256')\n        .update(stringify(copy))\n        .digest();\n    return base64url.encode(Buffer.from(digest));\n};\n/** convert compressed hex encoded private key to jwk */\nexport var privateJWKFromPrivateKeyHex = function (privateKeyHex) { return __awaiter(void 0, void 0, void 0, function () {\n    var jwk, kid;\n    return __generator(this, function (_a) {\n        jwk = __assign(__assign({}, keyto.from(privateKeyHex, 'blk').toJwk('private')), { crv: 'secp256k1' });\n        kid = getKid(jwk);\n        return [2 /*return*/, __assign(__assign({}, jwk), { kid: kid })];\n    });\n}); };\n/** convert compressed hex encoded public key to jwk */\nexport var publicJWKFromPublicKeyHex = function (publicKeyHex) { return __awaiter(void 0, void 0, void 0, function () {\n    var secp256k1, key, jwk, kid;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0: return [4 /*yield*/, instantiateSecp256k1()];\n            case 1:\n                secp256k1 = _a.sent();\n                key = publicKeyHex;\n                if (publicKeyHex.length === compressedHexEncodedPublicKeyLength) {\n                    key = binToHex(secp256k1.uncompressPublicKey(hexToBin(publicKeyHex)));\n                }\n                jwk = __assign(__assign({}, keyto.from(key, 'blk').toJwk('public')), { crv: 'secp256k1' });\n                kid = getKid(jwk);\n                return [2 /*return*/, __assign(__assign({}, jwk), { kid: kid })];\n        }\n    });\n}); };\n/** convert pem encoded private key to jwk */\nexport var privateJWKFromPrivateKeyPem = function (privateKeyPem) {\n    var jwk = __assign(__assign({}, keyto.from(privateKeyPem, 'pem').toJwk('private')), { crv: 'secp256k1' });\n    // console.log(jwk);\n    var kid = getKid(jwk);\n    return __assign(__assign({}, jwk), { kid: kid });\n};\n/** convert pem encoded private key to jwk */\nexport var publicJWKFromPublicKeyPem = function (publicKeyPem) {\n    var jwk = __assign(__assign({}, keyto.from(publicKeyPem, 'pem').toJwk('public')), { crv: 'secp256k1' });\n    var kid = getKid(jwk);\n    return __assign(__assign({}, jwk), { kid: kid });\n};\n/** convert jwk to hex encoded private key */\nexport var privateKeyHexFromJWK = function (jwk) { return __awaiter(void 0, void 0, void 0, function () {\n    return __generator(this, function (_a) {\n        return [2 /*return*/, keyto\n                .from(__assign(__assign({}, jwk), { crv: 'K-256' }), 'jwk')\n                .toString('blk', 'private')];\n    });\n}); };\n/** convert jwk to hex encoded public key */\nexport var publicKeyHexFromJWK = function (jwk) { return __awaiter(void 0, void 0, void 0, function () {\n    var secp256k1, uncompressedPublicKey, compressed;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0: return [4 /*yield*/, instantiateSecp256k1()];\n            case 1:\n                secp256k1 = _a.sent();\n                uncompressedPublicKey = keyto\n                    .from(__assign(__assign({}, jwk), { crv: 'K-256' }), 'jwk')\n                    .toString('blk', 'public');\n                compressed = secp256k1.compressPublicKey(hexToBin(uncompressedPublicKey));\n                return [2 /*return*/, binToHex(compressed)];\n        }\n    });\n}); };\n/** convert jwk to binary encoded private key */\nexport var privateKeyUInt8ArrayFromJWK = function (jwk) { return __awaiter(void 0, void 0, void 0, function () {\n    var privateKeyHex;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0: return [4 /*yield*/, privateKeyHexFromJWK(jwk)];\n            case 1:\n                privateKeyHex = _a.sent();\n                return [2 /*return*/, hexToBin(privateKeyHex)];\n        }\n    });\n}); };\n/** convert jwk to binary encoded public key */\nexport var publicKeyUInt8ArrayFromJWK = function (jwk) { return __awaiter(void 0, void 0, void 0, function () {\n    var publicKeyHex;\n    return __generator(this, function (_a) {\n        switch (_a.label) {\n            case 0: return [4 /*yield*/, publicKeyHexFromJWK(jwk)];\n            case 1:\n                publicKeyHex = _a.sent();\n                return [2 /*return*/, hexToBin(publicKeyHex)];\n        }\n    });\n}); };\nexport default {\n    binToHex: binToHex,\n    getKid: getKid,\n    hexToBin: hexToBin,\n    privateJWKFromPrivateKeyHex: privateJWKFromPrivateKeyHex,\n    privateJWKFromPrivateKeyPem: privateJWKFromPrivateKeyPem,\n    privateKeyHexFromJWK: privateKeyHexFromJWK,\n    privateKeyUInt8ArrayFromJWK: privateKeyUInt8ArrayFromJWK,\n    publicJWKFromPublicKeyHex: publicJWKFromPublicKeyHex,\n    publicJWKFromPublicKeyPem: publicJWKFromPublicKeyPem,\n    publicKeyHexFromJWK: publicKeyHexFromJWK,\n    publicKeyUInt8ArrayFromJWK: publicKeyUInt8ArrayFromJWK,\n};\n//# sourceMappingURL=keyUtils.js.map","import * as tslib_1 from \"tslib\";\nimport * as ES256K from '@transmute/es256k-jws-ts';\nimport base64url from 'base64url';\n/**\n * @ignore\n * Returns an object with an async sign function.\n * The sign function is bound to the KeyPair\n * and then returned by the KeyPair's signer method.\n * @param {EcdsaSecp256k1KeyClass2019} key - An EcdsaSecp256k1KeyClass2019.\n *\n * @returns {{sign: Function}} An object with an async function sign\n * using the private key passed in.\n */\nfunction joseSignerFactory(key) {\n    if (!key.privateKeyJwk) {\n        return {\n            sign({ data }) {\n                return tslib_1.__awaiter(this, void 0, void 0, function* () {\n                    throw new Error('No private key to sign with.');\n                });\n            },\n        };\n    }\n    return {\n        sign({ data }) {\n            return tslib_1.__awaiter(this, void 0, void 0, function* () {\n                const header = {\n                    alg: 'ES256K',\n                    b64: false,\n                    crit: ['b64'],\n                };\n                const toBeSigned = Buffer.from(data.buffer, data.byteOffset, data.length);\n                return ES256K.JWS.signDetached(toBeSigned, key.privateKeyJwk, header);\n            });\n        },\n    };\n}\n/**\n * @ignore\n * Returns an object with an async verify function.\n * The verify function is bound to the KeyPair\n * and then returned by the KeyPair's verifier method.\n * @param {EcdsaSecp256k1KeyClass2019} key - An EcdsaSecp256k1KeyClass2019.\n *\n * @returns {{verify: Function}} An async verifier specific\n * to the key passed in.\n */\nfunction joseVerifierFactory(key) {\n    if (!key.publicKeyJwk) {\n        return {\n            verify() {\n                return tslib_1.__awaiter(this, void 0, void 0, function* () {\n                    throw new Error('No public key to verify with.');\n                });\n            },\n        };\n    }\n    return {\n        verify({ data, signature }) {\n            return tslib_1.__awaiter(this, void 0, void 0, function* () {\n                const alg = 'ES256K';\n                const type = 'EcdsaSecp256k1VerificationKey2019';\n                const [encodedHeader, encodedSignature] = signature.split('..');\n                let header;\n                try {\n                    header = JSON.parse(base64url.decode(encodedHeader));\n                }\n                catch (e) {\n                    throw new Error('Could not parse JWS header; ' + e);\n                }\n                if (!(header && typeof header === 'object')) {\n                    throw new Error('Invalid JWS header.');\n                }\n                // confirm header matches all expectations\n                if (!(header.alg === alg &&\n                    header.b64 === false &&\n                    Array.isArray(header.crit) &&\n                    header.crit.length === 1 &&\n                    header.crit[0] === 'b64') &&\n                    Object.keys(header).length === 3) {\n                    throw new Error(`Invalid JWS header parameters for ${type}.`);\n                }\n                let verified = false;\n                const payload = Buffer.from(data.buffer, data.byteOffset, data.length);\n                try {\n                    yield ES256K.JWS.verifyDetached(signature, payload, key.publicKeyJwk);\n                    verified = true;\n                }\n                catch (e) {\n                    // tslint:disable-next-line:no-console\n                    // console.error('An error occurred when verifying signature: ', e);\n                }\n                return verified;\n            });\n        },\n    };\n}\nclass EcdsaSecp256k1KeyClass2019 {\n    /**\n     * Used to support importing of public keys from resolvers.\n     */\n    static from(options) {\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\n            return new EcdsaSecp256k1KeyClass2019(options);\n        });\n    }\n    /**\n     * Generates and returns a public key fingerprint using https://tools.ietf.org/html/rfc7638\n     *\n     * @param {string} publicKeyJwk - The jwk encoded public key material.\n     *\n     * @returns {string} The fingerprint.\n     */\n    static fingerprintFromPublicKey({ publicKeyJwk, }) {\n        const temp = Object.assign({}, publicKeyJwk);\n        delete temp.kid;\n        return ES256K.keyUtils.getKid(temp);\n    }\n    /**\n     * @param {KeyPairOptions} options - The options to use.\n     * @param {string} options.id - The key ID.\n     * @param {string} options.controller - The key controller.\n     * @param {string} options.publicKeyJwk - The JWK encoded Public Key.\n     * @param {string} options.privateKeyJwk - The JWK Private Key.\n     * @param {string} options.alg - The JWS alg for this key.\n     */\n    constructor(options) {\n        this.controller = options.controller;\n        this.type = options.type || 'EcdsaSecp256k1VerificationKey2019';\n        this.privateKeyJwk = options.privateKeyJwk;\n        this.publicKeyJwk = options.publicKeyJwk;\n        this.alg = 'ES256K';\n        if (this.publicKeyJwk === undefined) {\n            this.publicKeyJwk = Object.assign({}, this.privateKeyJwk);\n            delete this.publicKeyJwk.d;\n        }\n        this.id = options.id || this.controller + '#' + this.fingerprint();\n    }\n    //   /**\n    //    * Returns the JWK encoded public key.\n    //    *\n    //    * @returns {string} The JWK encoded public key.\n    //    */\n    //   get publicKey() {\n    //     return this.publicKeyJwk;\n    //   }\n    //   /**\n    //    * Returns the JWK encoded private key.\n    //    *\n    //    * @returns {string} The JWK encoded private key.\n    //    */\n    //   get privateKey() {\n    //     return this.privateKeyJwk;\n    //   }\n    /**\n     * Returns a signer object for use with jsonld-signatures.\n     *\n     * @returns {{sign: Function}} A signer for the json-ld block.\n     */\n    signer() {\n        return joseSignerFactory(this);\n    }\n    /**\n     * Returns a verifier object for use with jsonld-signatures.\n     *\n     * @returns {{verify: Function}} Used to verify jsonld-signatures.\n     */\n    verifier() {\n        return joseVerifierFactory(this);\n    }\n    /**\n     * Adds a public key base to a public key node.\n     *\n     * @param {Object} publicKeyNode - The public key node in a jsonld-signature.\n     * @param {string} publicKeyNode.publicKeyJwk - JWK Public Key for\n     *   jsonld-signatures.\n     *\n     * @returns {Object} A PublicKeyNode in a block.\n     */\n    addEncodedPublicKey(publicKeyNode) {\n        publicKeyNode.publicKeyJwk = this.publicKeyJwk;\n        return publicKeyNode;\n    }\n    /**\n     * Generates and returns a public key fingerprint using https://tools.ietf.org/html/rfc7638\n     *\n     * @returns {string} The fingerprint.\n     */\n    fingerprint() {\n        const temp = Object.assign({}, this.publicKeyJwk);\n        delete temp.kid;\n        return ES256K.keyUtils.getKid(temp);\n    }\n    //   /**\n    //    * Tests whether the fingerprint was generated from a given key pair.\n    //    *\n    //    * @param {string} fingerprint - A JWK public key.\n    //    *\n    //    * @returns {Object} An object indicating valid is true or false.\n    //    */\n    //   verifyFingerprint(/*fingerprint*/) {\n    //     // TODO: implement\n    //     throw new Error('`verifyFingerprint` API is not implemented.');\n    //   }\n    /**\n     * Contains the public key for the KeyPair\n     * and other information that json-ld Signatures can use to form a proof.\n     * @param {Object} [options={}] - Needs either a controller or owner.\n     * @param {string} [options.controller=this.controller]  - DID of the\n     * person/entity controlling this key pair.\n     *\n     * @returns {Object} A public node with\n     * information used in verification methods by signatures.\n     */\n    publicNode() {\n        const controller = this.controller;\n        const publicNode = {\n            id: this.id,\n            type: this.type,\n        };\n        if (controller) {\n            publicNode.controller = controller;\n        }\n        this.addEncodedPublicKey(publicNode); // Subclass-specific\n        return publicNode;\n    }\n}\nexport default EcdsaSecp256k1KeyClass2019;\n//# sourceMappingURL=EcdsaSecp256k1KeyClass2019.js.map","import * as tslib_1 from \"tslib\";\nimport jsonld from 'jsonld';\nimport jsigs from 'jsonld-signatures';\nconst { suites: { LinkedDataSignature }, } = jsigs;\nexport { LinkedDataSignature };\nimport EcdsaSecp256k1KeyClass2019 from './EcdsaSecp256k1KeyClass2019';\nconst requiredKeyType = 'EcdsaSecp256k1VerificationKey2019';\nconst proofSignatureKey = 'jws';\nclass EcdsaSecp256k1Signature2019 extends LinkedDataSignature {\n    /**\n     * @param linkedDataSigantureType {string} The name of the signature suite.\n     * @param linkedDataSignatureVerificationKeyType {string} The name verification key type for the signature suite.\n     *\n     * @param alg {string} JWS alg provided by subclass.\n     * @param [LDKeyClass] {LDKeyClass} provided by subclass or subclass\n     *   overrides `getVerificationMethod`.\n     *\n     *\n     * This parameter is required for signing:\n     *\n     * @param [signer] {function} an optional signer.\n     *\n     * @param [proofSignatureKey] {string} the property in the proof that will contain the signature.\n     * @param [date] {string|Date} signing date to use if not passed.\n     * @param [key] {LDKeyPair} an optional crypto-ld KeyPair.\n     * @param [useNativeCanonize] {boolean} true to use a native canonize\n     *   algorithm.\n     */\n    constructor({ signer, key, date, useNativeCanonize }) {\n        super({\n            type: 'EcdsaSecp256k1Signature2019',\n            LDKeyClass: EcdsaSecp256k1KeyClass2019,\n            date,\n            useNativeCanonize,\n        });\n        this.alg = 'ES256K';\n        this.LDKeyClass = EcdsaSecp256k1KeyClass2019;\n        if (key) {\n            const publicKey = key.publicNode();\n            this.verificationMethod = publicKey.id;\n            this.key = key;\n            if (typeof key.signer === 'function') {\n                this.signer = key.signer();\n            }\n            if (typeof key.verifier === 'function') {\n                this.verifier = key.verifier(key, this.alg, this.type);\n            }\n        }\n    }\n    /**\n     * Produces a linked data signature.\n     *\n     * @param verifyData {Uint8Array}.\n     * @param proof {object}\n     *\n     * @returns {Promise<{object}>} the proof containing the signature value.\n     */\n    sign({ verifyData, proof }) {\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\n            if (!(this.signer && typeof this.signer.sign === 'function')) {\n                throw new Error('A signer API has not been specified.');\n            }\n            proof[proofSignatureKey] = yield this.signer.sign({\n                data: verifyData,\n            });\n            return proof;\n        });\n    }\n    /**\n     * Verifies a linked data signature\n     *\n     * @param verifyData {Uint8Array}.\n     * @param verificationMethod {object}.\n     * @param document {object} the document the proof applies to.\n     * @param proof {object} the proof to be verified.\n     * @param purpose {ProofPurpose}\n     * @param documentLoader {function}\n     * @param expansionMap {function}\n     *\n     * @returns {Promise<{boolean}>} Resolves with the verification result.\n     */\n    verifySignature({ verifyData, verificationMethod, proof }) {\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\n            let { verifier } = this;\n            if (!verifier) {\n                const key = yield this.LDKeyClass.from(verificationMethod);\n                verifier = key.verifier(key, this.alg, this.type);\n            }\n            return verifier.verify({\n                data: Buffer.from(verifyData),\n                signature: proof[proofSignatureKey],\n            });\n        });\n    }\n    /** ensure there is a way to verify */\n    assertVerificationMethod({ verificationMethod }) {\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\n            if (!jsonld.hasValue(verificationMethod, 'type', requiredKeyType)) {\n                throw new Error(`Invalid key type. Key type must be \"${requiredKeyType}\".`);\n            }\n        });\n    }\n    /** used by linked data signatures and vc libraries */\n    getVerificationMethod({ proof, documentLoader }) {\n        const _super = Object.create(null, {\n            getVerificationMethod: { get: () => super.getVerificationMethod }\n        });\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\n            if (this.key) {\n                return this.key.publicNode();\n            }\n            const verificationMethod = yield _super.getVerificationMethod.call(this, {\n                proof,\n                documentLoader,\n            });\n            yield this.assertVerificationMethod({ verificationMethod });\n            return verificationMethod;\n        });\n    }\n    /** used by linked data signatures and vc libraries */\n    matchProof({ proof, document, purpose, documentLoader, expansionMap, }) {\n        const _super = Object.create(null, {\n            matchProof: { get: () => super.matchProof }\n        });\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\n            if (!(yield _super.matchProof.call(this, {\n                proof,\n                document,\n                purpose,\n                documentLoader,\n                expansionMap,\n            }))) {\n                return false;\n            }\n            if (!this.key) {\n                // no key specified, so assume this suite matches and it can be retrieved\n                return true;\n            }\n            const { verificationMethod } = proof;\n            // only match if the key specified matches the one in the proof\n            if (typeof verificationMethod === 'object') {\n                return verificationMethod.id === this.key.id;\n            }\n            return verificationMethod === this.key.id;\n        });\n    }\n}\nexport default EcdsaSecp256k1Signature2019;\n//# sourceMappingURL=EcdsaSecp256k1Signature2019.js.map","import * as tslib_1 from \"tslib\";\nimport jsonld from 'jsonld';\nimport resolver from './universalResolver';\nconst _nodejs = \n// tslint:disable-next-line\ntypeof process !== 'undefined' && process.versions && process.versions.node;\nconst _browser = \n// tslint:disable-next-line\n!_nodejs && (typeof window !== 'undefined' || typeof self !== 'undefined');\nconst documentLoader = _browser\n    ? jsonld.documentLoaders.xhr()\n    : jsonld.documentLoaders.node();\nexport default (url) => tslib_1.__awaiter(this, void 0, void 0, function* () {\n    // console.log(url);\n    // are we handling a DID?\n    if (url.indexOf('did:') === 0) {\n        const doc = yield resolver.resolve(url);\n        // TODO: add proper jsonld logic for iterating all possible DID URIs.\n        if (url.indexOf('#')) {\n            // iterate public keys, find the correct id...\n            for (const publicKey of doc.publicKey) {\n                if (publicKey.id === url) {\n                    return {\n                        contextUrl: null,\n                        document: publicKey,\n                        documentUrl: url,\n                    };\n                }\n            }\n        }\n        return {\n            contextUrl: null,\n            document: doc,\n            documentUrl: url,\n        };\n    }\n    //   is this a published (public) context?\n    return documentLoader(url);\n});\n//# sourceMappingURL=defaultDocumentLoader.js.map","const transformArrays = [\n    'assertionMethod',\n    'authentication',\n    'capabilityDelegation',\n    'capabilityInvocation',\n];\nconst transformObjects = ['publicKey', 'keyAgreement'];\nconst convertFragmentsToURIs = (didDocument) => {\n    const convertedDidDocument = JSON.parse(JSON.stringify(Object.assign({}, didDocument)));\n    transformObjects.forEach((property) => {\n        if (convertedDidDocument[property]) {\n            convertedDidDocument[property].forEach((value) => {\n                if (value.id[0] === '#') {\n                    value.id = convertedDidDocument.id + value.id;\n                }\n                if (!value.controller) {\n                    value.controller = convertedDidDocument.id;\n                }\n            });\n        }\n    });\n    transformArrays.forEach((property) => {\n        if (convertedDidDocument[property]) {\n            convertedDidDocument[property] = convertedDidDocument[property].map((value) => {\n                if (value[0] === '#') {\n                    return convertedDidDocument.id + value;\n                }\n                return value;\n            });\n        }\n    });\n    return convertedDidDocument;\n};\nexport default convertFragmentsToURIs;\n//# sourceMappingURL=convertFragmentsToURIs.js.map","import * as tslib_1 from \"tslib\";\nimport fetch from 'node-fetch';\nimport convertFragmentsToURIs from './convertFragmentsToURIs';\nconst getJson = (url) => tslib_1.__awaiter(this, void 0, void 0, function* () {\n    return fetch(url, {\n        headers: {\n            Accept: 'application/ld+json',\n        },\n        method: 'get',\n    }).then((data) => data.json());\n});\nexport const normalizeDocument = (res) => {\n    const didDoc = res.id && res.id.indexOf('did:') === 0 ? res : Object.assign({}, res.didDocument);\n    // hack for BTCR.\n    if (res.methodMetadata) {\n        if (res.methodMetadata.continuation.publicKey) {\n            didDoc.publicKey = res.methodMetadata.continuation.publicKey;\n        }\n        if (res.methodMetadata.continuation.assertionMethod) {\n            didDoc.assertionMethod = res.methodMetadata.continuation.assertionMethod;\n        }\n        if (res.methodMetadata.continuation.authentication) {\n            didDoc.authentication = res.methodMetadata.continuation.authentication;\n        }\n        if (res.methodMetadata.continuation.capabilityInvocation) {\n            didDoc.capabilityInvocation =\n                res.methodMetadata.continuation.capabilityInvocation;\n        }\n        if (res.methodMetadata.continuation.capabilityDelegation) {\n            didDoc.capabilityDelegation =\n                res.methodMetadata.continuation.capabilityDelegation;\n        }\n        if (res.methodMetadata.continuation.keyAgreement) {\n            didDoc.keyAgreement = res.methodMetadata.continuation.keyAgreement;\n        }\n    }\n    return didDoc;\n};\nexport default {\n    resolve: (didUri) => tslib_1.__awaiter(this, void 0, void 0, function* () {\n        try {\n            const didMethod = didUri\n                .split(':')\n                .splice(0, 2)\n                .join(':');\n            let res;\n            // this avoids jsonld parsing done the universal resolver,\n            // which sometimes breaks things.\n            switch (didMethod) {\n                case 'did:elem':\n                    res = yield getJson('https://element-did.com/api/v1/sidetree/' + didUri);\n                    break;\n                default:\n                    res = yield getJson('https://uniresolver.io/1.0/identifiers/' + didUri);\n            }\n            if (res.didDocument === null) {\n                throw new Error('Could not resolve DID with Universal Resolver.');\n            }\n            const normalizedDoc = yield normalizeDocument(res);\n            const deFragmented = convertFragmentsToURIs(normalizedDoc);\n            const finalDoc = deFragmented;\n            return finalDoc;\n        }\n        catch (e) {\n            // tslint:disable-next-line:no-console\n            // console.error('Could not resolve: ' + didUri);\n            throw new Error(e);\n        }\n    }),\n};\n//# sourceMappingURL=universalResolver.js.map","import { __awaiter, __extends, __generator } from \"tslib\";\nimport base64url from 'base64url';\nimport { binToHex, hexToBin, instantiateSecp256k1 } from 'bitcoin-ts';\nimport crypto from 'crypto';\nimport { privateKeyUInt8ArrayFromJWK, publicKeyUInt8ArrayFromJWK, } from './keyUtils';\n/** error matching @panva/jose for JWS verification failure. */\nvar JWSVerificationFailed = /** @class */ (function (_super) {\n    __extends(JWSVerificationFailed, _super);\n    function JWSVerificationFailed(message) {\n        var _this = _super.call(this, message) || this;\n        _this.name = 'JWSVerificationFailed';\n        return _this;\n    }\n    return JWSVerificationFailed;\n}(Error));\n/** Produce a JWS Unencoded Payload per https://tools.ietf.org/html/rfc7797#section-6 */\nexport var signDetached = function (\n// in the case of EcdsaSecp256k1Signature2019 this is the result of createVerifyData\npayload, privateKeyJWK, header) {\n    if (header === void 0) { header = {\n        alg: 'ES256K',\n        b64: false,\n        crit: ['b64'],\n    }; }\n    return __awaiter(void 0, void 0, void 0, function () {\n        var privateKeyUInt8Array, secp256k1, encodedHeader, toBeSignedBuffer, message, digest, messageHashUInt8Array, signatureUInt8Array, signatureHex, encodedSignature;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, privateKeyUInt8ArrayFromJWK(privateKeyJWK)];\n                case 1:\n                    privateKeyUInt8Array = _a.sent();\n                    return [4 /*yield*/, instantiateSecp256k1()];\n                case 2:\n                    secp256k1 = _a.sent();\n                    encodedHeader = base64url.encode(JSON.stringify(header));\n                    toBeSignedBuffer = Buffer.concat([\n                        Buffer.from(encodedHeader + '.', 'utf8'),\n                        Buffer.from(payload.buffer, payload.byteOffset, payload.length),\n                    ]);\n                    message = Buffer.from(toBeSignedBuffer);\n                    digest = crypto\n                        .createHash('sha256')\n                        .update(message)\n                        .digest()\n                        .toString('hex');\n                    messageHashUInt8Array = hexToBin(digest);\n                    signatureUInt8Array = secp256k1.signMessageHashCompact(privateKeyUInt8Array, messageHashUInt8Array);\n                    signatureHex = binToHex(signatureUInt8Array);\n                    encodedSignature = base64url.encode(Buffer.from(signatureHex, 'hex'));\n                    return [2 /*return*/, encodedHeader + \"..\" + encodedSignature];\n            }\n        });\n    });\n};\n/** Verify a JWS Unencoded Payload per https://tools.ietf.org/html/rfc7797#section-6 */\nexport var verifyDetached = function (jws, payload, publicKeyJWK) { return __awaiter(void 0, void 0, void 0, function () {\n    var _a, encodedHeader, encodedSignature, header, publicKeyUInt8Array, secp256k1, toBeSignedBuffer, message, digest, messageHashUInt8Array, signatureUInt8Array, verified;\n    return __generator(this, function (_b) {\n        switch (_b.label) {\n            case 0:\n                if (jws.indexOf('..') === -1) {\n                    throw new JWSVerificationFailed('not a valid rfc7797 jws.');\n                }\n                _a = jws.split('..'), encodedHeader = _a[0], encodedSignature = _a[1];\n                header = JSON.parse(base64url.decode(encodedHeader));\n                if (header.alg !== 'ES256K') {\n                    throw new Error('JWS alg is not signed with ES256K.');\n                }\n                if (header.b64 !== false ||\n                    !header.crit ||\n                    !header.crit.length ||\n                    header.crit[0] !== 'b64') {\n                    throw new Error('JWS Header is not in rfc7797 format (not detached).');\n                }\n                return [4 /*yield*/, publicKeyUInt8ArrayFromJWK(publicKeyJWK)];\n            case 1:\n                publicKeyUInt8Array = _b.sent();\n                return [4 /*yield*/, instantiateSecp256k1()];\n            case 2:\n                secp256k1 = _b.sent();\n                toBeSignedBuffer = Buffer.concat([\n                    Buffer.from(encodedHeader + '.', 'utf8'),\n                    Buffer.from(payload.buffer, payload.byteOffset, payload.length),\n                ]);\n                message = Buffer.from(toBeSignedBuffer);\n                digest = crypto\n                    .createHash('sha256')\n                    .update(message)\n                    .digest()\n                    .toString('hex');\n                messageHashUInt8Array = hexToBin(digest);\n                signatureUInt8Array = hexToBin(base64url.toBuffer(encodedSignature).toString('hex'));\n                verified = secp256k1.verifySignatureCompact(signatureUInt8Array, publicKeyUInt8Array, messageHashUInt8Array);\n                if (verified) {\n                    return [2 /*return*/, true];\n                }\n                throw new Error('Cannot verify detached signature.');\n        }\n    });\n}); };\n/** Produce a normal ES256K JWS */\nexport var sign = function (payload, privateKeyJWK, header) {\n    if (header === void 0) { header = { alg: 'ES256K' }; }\n    return __awaiter(void 0, void 0, void 0, function () {\n        var privateKeyUInt8Array, secp256k1, encodedHeader, encodedPayload, toBeSigned, message, digest, messageHashUInt8Array, signatureUInt8Array, signatureHex, encodedSignature;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0: return [4 /*yield*/, privateKeyUInt8ArrayFromJWK(privateKeyJWK)];\n                case 1:\n                    privateKeyUInt8Array = _a.sent();\n                    return [4 /*yield*/, instantiateSecp256k1()];\n                case 2:\n                    secp256k1 = _a.sent();\n                    encodedHeader = base64url.encode(JSON.stringify(header));\n                    encodedPayload = base64url.encode(JSON.stringify(payload));\n                    toBeSigned = encodedHeader + \".\" + encodedPayload;\n                    message = Buffer.from(toBeSigned);\n                    digest = crypto\n                        .createHash('sha256')\n                        .update(message)\n                        .digest()\n                        .toString('hex');\n                    messageHashUInt8Array = hexToBin(digest);\n                    signatureUInt8Array = secp256k1.signMessageHashCompact(privateKeyUInt8Array, messageHashUInt8Array);\n                    signatureHex = binToHex(signatureUInt8Array);\n                    encodedSignature = base64url.encode(Buffer.from(signatureHex, 'hex'));\n                    return [2 /*return*/, encodedHeader + \".\" + encodedPayload + \".\" + encodedSignature];\n            }\n        });\n    });\n};\n/** Verify an ES256K JWS, returns the decoded object if successful, throws otherwise. */\nexport var verify = function (jws, publicKeyJWK) { return __awaiter(void 0, void 0, void 0, function () {\n    var secp256k1, publicKeyUInt8Array, _a, encodedHeader, encodedPayload, encodedSignature, toBeSigned, message, digest, messageHashUInt8Array, signatureUInt8Array, verified;\n    return __generator(this, function (_b) {\n        switch (_b.label) {\n            case 0: return [4 /*yield*/, instantiateSecp256k1()];\n            case 1:\n                secp256k1 = _b.sent();\n                return [4 /*yield*/, publicKeyUInt8ArrayFromJWK(publicKeyJWK)];\n            case 2:\n                publicKeyUInt8Array = _b.sent();\n                _a = jws.split('.'), encodedHeader = _a[0], encodedPayload = _a[1], encodedSignature = _a[2];\n                toBeSigned = encodedHeader + \".\" + encodedPayload;\n                message = Buffer.from(toBeSigned);\n                digest = crypto\n                    .createHash('sha256')\n                    .update(message)\n                    .digest()\n                    .toString('hex');\n                messageHashUInt8Array = hexToBin(digest);\n                signatureUInt8Array = hexToBin(base64url.toBuffer(encodedSignature).toString('hex'));\n                verified = secp256k1.verifySignatureCompact(signatureUInt8Array, publicKeyUInt8Array, messageHashUInt8Array);\n                if (verified) {\n                    return [2 /*return*/, JSON.parse(base64url.decode(encodedPayload))];\n                }\n                throw new JWSVerificationFailed('signature verification failed');\n        }\n    });\n}); };\n/** decode a JWS (without verifying it) */\nexport var decode = function (jws, options) {\n    if (options === void 0) { options = { complete: false }; }\n    var _a = jws.split('.'), encodedHeader = _a[0], encodedPayload = _a[1], encodedSignature = _a[2];\n    if (options.complete) {\n        return {\n            header: JSON.parse(base64url.decode(encodedHeader)),\n            payload: JSON.parse(base64url.decode(encodedPayload)),\n            signature: encodedSignature,\n        };\n    }\n    return JSON.parse(base64url.decode(encodedPayload));\n};\nexport default {\n    decode: decode,\n    sign: sign,\n    signDetached: signDetached,\n    verify: verify,\n    verifyDetached: verifyDetached,\n};\n//# sourceMappingURL=JWS.js.map","export { default as EcdsaSecp256k1KeyClass2019, } from './EcdsaSecp256k1KeyClass2019';\nexport { default as EcdsaSecp256k1Signature2019, } from './EcdsaSecp256k1Signature2019';\nexport { default as defaultDocumentLoader } from './defaultDocumentLoader';\n//# sourceMappingURL=index.js.map","import React from 'react';\n\nconst jsigs = require('jsonld-signatures');\n\nconst { AssertionProofPurpose } = jsigs.purposes;\n\nconst {\n  EcdsaSecp256k1KeyClass2019,\n  EcdsaSecp256k1Signature2019,\n  defaultDocumentLoader,\n} = require('@transmute/lds-ecdsa-secp256k1-2019');\n\nconst vc = require('vc-js');\n\nclass App extends React.Component {\n  state = {};\n  async componentWillMount() {\n    const doc = {\n      '@context': [\n        {\n          schema: 'http://schema.org/',\n          name: 'schema:name',\n          homepage: 'schema:url',\n          image: 'schema:image',\n        },\n      ],\n      name: 'Manu Sporny',\n      homepage: 'https://manu.sporny.org/',\n      image: 'https://manu.sporny.org/images/manu.png',\n    };\n    this.setState({\n      doc,\n    });\n    const key = new EcdsaSecp256k1KeyClass2019({\n      id:\n        'did:elem:ropsten:EiChaglAoJaBq7bGWp6bA5PAQKaOTzVHVXIlJqyQbljfmg#qfknmVDhMi3Uc190IHBRfBRqMgbEEBRzWOj1E9EmzwM',\n      controller: 'did:elem:ropsten:EiChaglAoJaBq7bGWp6bA5PAQKaOTzVHVXIlJqyQbljfmg',\n      privateKeyJwk: {\n        kty: 'EC',\n        crv: 'secp256k1',\n        d: 'wNZx20zCHoOehqaBOFsdLELabfv8sX0612PnuAiyc-g',\n        x: 'NbASvplLIO_XTzP9R69a3MuqOO0DQw2LGnhJjirpd4w',\n        y: 'EiZOvo9JWPz1yGlNNW66IV8uA44EQP_Yv_E7OZl1NG0',\n        kid: 'qfknmVDhMi3Uc190IHBRfBRqMgbEEBRzWOj1E9EmzwM',\n      },\n    });\n\n    const suite = new EcdsaSecp256k1Signature2019({\n      key,\n    });\n    const signed = await jsigs.sign(doc, {\n      compactProof: false,\n      documentLoader: defaultDocumentLoader,\n      purpose: new AssertionProofPurpose(),\n      suite,\n    });\n\n    this.setState({\n      signed: signed,\n    });\n    const res = await jsigs.verify(signed, {\n      suite,\n\n      compactProof: false,\n      // controller: didDoc,\n      documentLoader: defaultDocumentLoader,\n      purpose: new AssertionProofPurpose(),\n    });\n    // Leave for development purposes\n    if (!res.verified) {\n      // tslint:disable-next-line:no-console\n      console.log(res);\n    }\n    this.setState({\n      verified: res,\n    });\n\n    // Sample unsigned credential\n    const credential = {\n      '@context': [\n        'https://www.w3.org/2018/credentials/v1',\n        'https://www.w3.org/2018/credentials/examples/v1',\n      ],\n      id: 'https://example.com/credentials/1872',\n      type: ['VerifiableCredential', 'AlumniCredential'],\n      issuer: key.controller,\n      issuanceDate: '2010-01-01T19:23:24Z',\n      credentialSubject: {\n        id: 'did:example:ebfeb1f712ebc6f1c276e12ec21',\n        alumniOf: 'Example University',\n      },\n    };\n\n    const signedVC = await vc.issue({ credential, suite });\n\n    this.setState({\n      vc_issued: signedVC,\n    });\n\n    const result = await vc.verify({\n      credential: signedVC,\n      suite,\n      documentLoader: defaultDocumentLoader,\n    });\n\n    this.setState({\n      vc_verified: result,\n    });\n  }\n  render() {\n    return (\n      <div className=\"App\">\n        <h5>EcdsaSecp256k1Signature2019</h5>\n        <pre>{JSON.stringify(this.state, null, 2)}</pre>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}